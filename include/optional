/** -*- mode: c++ -*-
 * @file   libcpp/include/optional
 * @author Peter Züger
 * @date   14.05.2019
 * @brief  23.6 Optional objects
 *
 * This file is part of libcpp (https://gitlab.com/peterzuger/libcpp).
 * Copyright (c) 2019 Peter Züger.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
#ifndef __OPTIONAL__
#define __OPTIONAL__

#include <__pair>
#include <initializer_list>
#include <type_traits>
#include <exception>

namespace std{
    // 23.6.4, no-value state indicator
    struct nullopt_t{};
    inline constexpr nullopt_t nullopt();

    // 23.6.5, class bad_optional_access
    class bad_optional_access: public exception{
    public:
        bad_optional_access();
    };

    [[noreturn]] inline void __throw_bad_optional_access(){
        #if defined(__cpp_exceptions)
        throw bad_optional_access();
        #else
        terminate();
        #endif /* defined(__cpp_exceptions) */
    }

    // 23.6.3, class template optional
    template<typename T>
    class optional{
    public:
        using value_type = T;

        // 23.6.3.1, constructors
        constexpr optional()noexcept;
        constexpr optional(nullopt_t)noexcept;
        constexpr optional(const optional&);
        constexpr optional(optional&&)noexcept(std::is_nothrow_move_constructible_v<T>);

        template<class... Args>
        constexpr explicit optional(std::in_place_t, Args&&...);

        template<class U, class... Args>
        constexpr explicit optional(std::in_place_t, initializer_list<U>, Args&&...);

        template<class U = T>
        explicit constexpr optional(U&&);

        template<class U>
        explicit optional(const optional<U>&);

        template<class U>
        explicit optional(optional<U>&&);

        // 23.6.3.2, destructor
        ~optional();

        // 23.6.3.3, assignment
        optional& operator=(nullopt_t)noexcept;
        optional& operator=(const optional&);
        optional& operator=(optional&&)noexcept(std::is_nothrow_move_assignable_v<T> &&
                                                std::is_nothrow_move_constructible_v<T>);

        template<class U = T>
        optional& operator=(U&&);

        template<class U>
        optional& operator=(const optional<U>&);

        template<class U>
        optional& operator=(optional<U>&&);

        template<class... Args>
        T& emplace(Args&&...);

        template<class U, class... Args>
        T& emplace(initializer_list<U>, Args&&...);

        // 23.6.3.4, swap
        void swap(optional&)noexcept(std::is_nothrow_move_constructible_v<T> &&
                                     std::is_nothrow_swappable_v<T>);

        // 23.6.3.5, observers
        constexpr const T* operator->()const;
        constexpr T* operator->();
        constexpr const T& operator*()const&;
        constexpr T& operator*()&;
        constexpr T&& operator*()&&;
        constexpr const T&& operator*()const&&;
        constexpr explicit operator bool()const noexcept;
        constexpr bool has_value()const noexcept;
        constexpr const T& value()const&;
        constexpr T& value()&;
        constexpr T&& value()&&;
        constexpr const T&& value()const&&;

        template<class U>
        constexpr T value_or(U&&)const&;

        template<class U>
        constexpr T value_or(U&&)&&;

        // 23.6.3.6, modifiers
        void reset()noexcept;

    private:
        T *val;// exposition only
    };

    // 23.6.6, relational operators
    template<class T, class U>
    constexpr bool operator==(const optional<T>& x, const optional<U>& y){
        if(bool(x) != bool(y))
            return false;
        if(bool(x) == false)
            return true;
        return *x == *y;
    }

    template<class T, class U>
    constexpr bool operator!=(const optional<T>& x, const optional<U>& y){
        if(bool(x) != bool(y))
            return true;
        if(bool(x) == false)
            return false;
        return *x != *y;
    }

    template<class T, class U>
    constexpr bool operator<(const optional<T>& x, const optional<U>& y){
        if(!y)
            return false;
        if(!x)
            return true;
        return *x < *y;
    }

    template<class T, class U>
    constexpr bool operator>(const optional<T>& x, const optional<U>& y){
        if(!x)
            return false;
        if(!y)
            return true;
        return *x > *y;
    }

    template<class T, class U>
    constexpr bool operator<=(const optional<T>& x, const optional<U>& y){
        if(!x)
            return true;
        if(!y)
            return false;
        return *x <= *y;
    }

    template<class T, class U>
    constexpr bool operator>=(const optional<T>& x, const optional<U>& y){
        if(!y)
            return true;
        if(!x)
            return false;
        return *x >= *y;
    }

    // 23.6.7, comparison with nullopt
    template<class T>
    constexpr bool operator==(const optional<T>& x, nullopt_t)noexcept{
        return !x;
    }

    template<class T>
    constexpr bool operator==(nullopt_t, const optional<T>& x)noexcept{
        return !x;
    }

    template<class T>
    constexpr bool operator!=(const optional<T>& x, nullopt_t)noexcept{
        return bool(x);
    }

    template<class T>
    constexpr bool operator!=(nullopt_t, const optional<T>& x)noexcept{
        return bool(x);
    }

    template<class T>
    constexpr bool operator<(const optional<T>&, nullopt_t)noexcept{
        return false;
    }

    template<class T>
    constexpr bool operator<(nullopt_t, const optional<T>& x)noexcept{
        return bool(x);
    }

    template<class T>
    constexpr bool operator<=(const optional<T>& x, nullopt_t)noexcept{
        return !x;
    }

    template<class T>
    constexpr bool operator<=(nullopt_t, const optional<T>&)noexcept{
        return true;
    }

    template<class T>
    constexpr bool operator>(const optional<T>& x, nullopt_t)noexcept{
        return bool(x);
    }

    template<class T>
    constexpr bool operator>(nullopt_t, const optional<T>&)noexcept{
        return false;
    }

    template<class T>
    constexpr bool operator>=(const optional<T>&, nullopt_t)noexcept{
        return true;
    }

    template<class T>
    constexpr bool operator>=(nullopt_t, const optional<T>& x)noexcept{
        return !x;
    }

    // 23.6.8, comparison with T
    template<class T, class U>
    constexpr bool operator==(const optional<T>& x, const U& v){
        return bool(x) ? *x == v : false;
    }

    template<class T, class U>
    constexpr bool operator==(const U& v, const optional<T>& x){
        return bool(x) ? v == *x : false;
    }

    template<class T, class U>
    constexpr bool operator!=(const optional<T>& x, const U& v){
        return bool(x) ? *x != v : true;
    }

    template<class T, class U>
    constexpr bool operator!=(const U& v, const optional<T>& x){
        return bool(x) ? v != *x : true;
    }

    template<class T, class U>
    constexpr bool operator<(const optional<T>& x, const U& v){
        return bool(x) ? *x < v : true;
    }

    template<class T, class U>
    constexpr bool operator<(const U& v, const optional<T>& x){
        return bool(x) ? v < *x : false;
    }

    template<class T, class U>
    constexpr bool operator<=(const optional<T>& x, const U& v){
        return bool(x) ? *x <= v : true;
    }

    template<class T, class U>
    constexpr bool operator<=(const U& v, const optional<T>& x){
        return bool(x) ? v <= *x : false;
    }

    template<class T, class U>
    constexpr bool operator>(const optional<T>& x, const U& v){
        return bool(x) ? *x > v : false;
    }

    template<class T, class U>
    constexpr bool operator>(const U& v, const optional<T>& x){
        return bool(x) ? v > *x : true;
    }

    template<class T, class U>
    constexpr bool operator>=(const optional<T>& x, const U& v){
        return bool(x) ? *x >= v : false;
    }

    template<class T, class U>
    constexpr bool operator>=(const U& v, const optional<T>& x){
        return bool(x) ? v >= *x : true;
    }

    // 23.6.9, specialized algorithms
    template<class T>void swap(optional<T>& x, optional<T>& y)noexcept(noexcept(x.swap(y)));
    template<class T>constexpr optional<std::decay_t<T>> make_optional(T&&);
    template<class T, class... Args>constexpr optional<T> make_optional(Args&&... args);
    template<class T, class U, class... Args>
    constexpr optional<T> make_optional(initializer_list<U> il, Args&&... args);

    // 23.6.10, hash support
    template<class T> struct hash;
    template<class T> struct hash<optional<T>>;
}

#endif /* __OPTIONAL__ */
