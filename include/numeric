/** -*- mode: c++ -*-
 * @file   libcpp/include/numeric
 * @author Peter Züger
 * @date   14.05.2019
 * @brief  Generalized numeric operations
 *
 * This file is part of libcpp (https://gitlab.com/peterzuger/libcpp).
 * Copyright (c) 2019 Peter Züger.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
#ifndef __NUMERIC__
#define __NUMERIC__

#include <__execution/numeric>
#include <__iterator_traits>
#include <type_traits>

namespace std{
    // 29.8.2, accumulate
    template<class InputIterator, class T>
    T accumulate(InputIterator first, InputIterator last, T init);

    template<class InputIterator, class T, class BinaryOperation>
    T accumulate(InputIterator first, InputIterator last, T init, BinaryOperation binary_op);


    // 29.8.3, reduce
    template<class InputIterator>
    typename std::iterator_traits<InputIterator>::value_type reduce(InputIterator first, InputIterator last);

    template<class InputIterator, class T>
    T reduce(InputIterator first, InputIterator last, T init);

    template<class InputIterator, class T, class BinaryOperation>
    T reduce(InputIterator first, InputIterator last, T init, BinaryOperation binary_op);


    // 29.8.4, inner product
    template<class InputIterator1, class InputIterator2, class T>
    T inner_product(InputIterator1 first1, InputIterator1 last1,
                    InputIterator2 first2, T init);

    template<class InputIterator1, class InputIterator2, class T,
             class BinaryOperation1, class BinaryOperation2>
    T inner_product(InputIterator1 first1, InputIterator1 last1,
                    InputIterator2 first2, T init,
                    BinaryOperation1 binary_op1, BinaryOperation2 binary_op2);


    // 29.8.5, transform reduce
    template<class InputIterator1, class InputIterator2, class T>
    T transform_reduce(InputIterator1 first1, InputIterator1 last1,
                       InputIterator2 first2, T init);

    template<class InputIterator1, class InputIterator2, class T,
             class BinaryOperation1, class BinaryOperation2>
    T transform_reduce(InputIterator1 first1, InputIterator1 last1,
                       InputIterator2 first2, T init,
                       BinaryOperation1 binary_op1, BinaryOperation2 binary_op2);

    template<class InputIterator, class T, class BinaryOperation, class UnaryOperation>
    T transform_reduce(InputIterator first, InputIterator last, T init,
                       BinaryOperation binary_op, UnaryOperation unary_op);


    // 29.8.6, partial sum
    template<class InputIterator, class OutputIterator>
    OutputIterator partial_sum(InputIterator first, InputIterator last, OutputIterator result);

    template<class InputIterator, class OutputIterator, class BinaryOperation>
    OutputIterator partial_sum(InputIterator first, InputIterator last,
                               OutputIterator result, BinaryOperation binary_op);


    // 29.8.7, exclusive scan
    template<class InputIterator, class OutputIterator, class T>
    OutputIterator exclusive_scan(InputIterator first, InputIterator last,
                                  OutputIterator result, T init);

    template<class InputIterator, class OutputIterator, class T, class BinaryOperation>
    OutputIterator exclusive_scan(InputIterator first, InputIterator last,
                                  OutputIterator result, T init, BinaryOperation binary_op);


    // 29.8.8, inclusive scan
    template<class InputIterator, class OutputIterator>
    OutputIterator inclusive_scan(InputIterator first, InputIterator last,
                                  OutputIterator result);

    template<class InputIterator, class OutputIterator, class BinaryOperation>
    OutputIterator inclusive_scan(InputIterator first, InputIterator last,
                                  OutputIterator result, BinaryOperation binary_op);

    template<class InputIterator, class OutputIterator, class BinaryOperation, class T>
    OutputIterator inclusive_scan(InputIterator first, InputIterator last, OutputIterator result,
                                  BinaryOperation binary_op, T init);


    // 29.8.9, transform exclusive scan
    template<class InputIterator, class OutputIterator, class T, class BinaryOperation, class UnaryOperation>
    OutputIterator transform_exclusive_scan(InputIterator first, InputIterator last,
                                            OutputIterator result, T init,
                                            BinaryOperation binary_op, UnaryOperation unary_op);


    // 29.8.10, transform inclusive scan
    template<class InputIterator, class OutputIterator, class BinaryOperation, class UnaryOperation>
    OutputIterator transform_inclusive_scan(InputIterator first, InputIterator last, OutputIterator result,
                                            BinaryOperation binary_op, UnaryOperation unary_op);

    template<class InputIterator, class OutputIterator, class BinaryOperation, class UnaryOperation, class T>
    OutputIterator transform_inclusive_scan(InputIterator first, InputIterator last, OutputIterator result,
                                            BinaryOperation binary_op, UnaryOperation unary_op,
                                            T init);


    // 29.8.11, adjacent difference
    template<class InputIterator, class OutputIterator>
    OutputIterator adjacent_difference(InputIterator first, InputIterator last, OutputIterator result);

    template<class InputIterator, class OutputIterator, class BinaryOperation>
    OutputIterator adjacent_difference(InputIterator first, InputIterator last,
                                       OutputIterator result, BinaryOperation binary_op);


    // 29.8.12, iota
    template<class ForwardIterator, class T>
    void iota(ForwardIterator first, ForwardIterator last, T value);


    // 29.8.13, greatest common divisor
    template<class M, class N>
    constexpr std::common_type_t<M, N> gcd(M m, N n);


    // 29.8.14, least common multiple
    template<class M, class N>
    constexpr std::common_type_t<M, N> lcm(M m, N n);
}

#endif /* __NUMERIC__ */
